#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'json'
require 'open3'
require 'rexml/document'
require 'tmpdir'

# Reproduces flaky specs locally by downloading CI artifacts and running rspec --bisect
# See: https://depo-platform-documentation.scrollhelp.site/developer-docs/handling-flaky-unit-tests

class FlakySpecBisect
  REPO = 'department-of-veterans-affairs/vets-api'

  def initialize(url_or_run_id, options = {})
    @run_id = extract_run_id(url_or_run_id)
    @group = options[:group]
    @dry_run = options[:dry_run]
    @verbose = options[:verbose]
    @skip_verify = options[:skip_verify]
    @download_dir = nil
    @original_ref = nil
  end

  def run
    puts "Analyzing GitHub Actions run: #{@run_id}"

    check_commit_mismatch

    failed_groups = find_failed_test_groups
    if failed_groups.empty?
      puts 'No failed test groups found in this run.'
      puts 'Tip: This tool works best with runs that have test failures.'
      exit 1
    end

    puts "Found #{failed_groups.length} failed test group(s): #{failed_groups.join(', ')}"
    filter_groups(failed_groups).each { |group| process_group(group) }
  end

  def filter_groups(failed_groups)
    return failed_groups unless @group

    matching = failed_groups.select { |g| g.include?(@group) }
    if matching.empty?
      puts "Error: Group '#{@group}' not found in failed groups"
      exit 1
    end
    matching
  end

  private

  def check_commit_mismatch
    ci_commit = fetch_ci_commit
    return unless ci_commit

    local_ref = current_git_ref
    local_commit = `git rev-parse HEAD`.strip
    return if local_commit.start_with?(ci_commit) || ci_commit.start_with?(local_commit)

    puts "\nWarning: CI ran on commit #{ci_commit[0, 7]} but you're on #{local_commit[0, 7]}"
    print "Check out commit #{ci_commit[0, 7]} now? [Y/n] "
    if $stdin.gets&.strip&.downcase != 'n'
      @original_ref = local_ref
      register_restore_hook
      system('git', 'checkout', ci_commit)
      puts
    end
  end

  def register_restore_hook
    original = @original_ref
    at_exit do
      next unless original

      puts "\nDone."
      print "Check out #{original} now? [Y/n] "
      system('git', 'checkout', original) if $stdin.gets&.strip&.downcase != 'n'
    end
  end

  def current_git_ref
    # Try to get branch name first, fall back to commit SHA
    branch = `git symbolic-ref --short HEAD 2>/dev/null`.strip
    branch.empty? ? `git rev-parse HEAD`.strip : branch
  end

  def fetch_ci_commit
    output, status = Open3.capture2(
      'gh', 'run', 'view', @run_id,
      '--repo', REPO,
      '--json', 'headSha',
      '--jq', '.headSha'
    )
    return nil unless status.success?

    output.strip.empty? ? nil : output.strip
  end

  def extract_run_id(url_or_id)
    return url_or_id if url_or_id.match?(/^\d+$/)

    match = url_or_id.match(%r{/actions/runs/(\d+)})
    if match
      match[1]
    else
      puts "Error: Could not extract run ID from: #{url_or_id}"
      puts "Expected format: https://github.com/#{REPO}/actions/runs/12345678 or just 12345678"
      exit 1
    end
  end

  def find_failed_test_groups
    output, status = Open3.capture2(
      'gh', 'run', 'view', @run_id,
      '--repo', REPO,
      '--json', 'jobs',
      '--jq', '.jobs[] | select(.conclusion == "failure") | .name'
    )

    unless status.success?
      puts "Error: Failed to fetch run info. Make sure you're authenticated with 'gh auth login'"
      exit 1
    end

    output.lines.map(&:strip).select { |name| name.start_with?('Test (Group') }
  rescue Errno::ENOENT
    puts 'Error: GitHub CLI (gh) not found. Install from https://cli.github.com/'
    exit 1
  end

  def process_group(group_name)
    puts "\n#{'=' * 60}"
    puts "Processing: #{group_name}"
    puts '=' * 60

    artifact_name = artifact_name_for_group(group_name)
    xml_content = download_artifact(artifact_name)
    seed, spec_files, failures = parse_xml(xml_content)

    puts "Seed: #{seed}"
    puts "Spec files: #{spec_files.length}"
    puts "Files: #{spec_files.first(3).join(', ')}#{spec_files.length > 3 ? '...' : ''}" if @verbose
    print_failures(failures)

    failed_files = failures.map { |f| f[:file] }.compact.uniq
    run_bisect(seed, spec_files, failed_files)
  end

  def artifact_name_for_group(group_name)
    match = group_name.match(/Group\s*(\d+)/)
    unless match
      puts "Error: Could not extract group number from '#{group_name}'"
      exit 1
    end
    "Test Results Group #{match[1]}"
  end

  def print_failures(failures)
    return if failures.empty?

    puts "\nFailed specs (#{failures.length}):"
    failures.each do |failure|
      puts "  - #{failure[:file]}"
      puts "    #{failure[:name]}"
      puts "    #{failure[:message]}" if @verbose && failure[:message]
    end
  end

  def download_artifact(artifact_name)
    Dir.mktmpdir('flaky-spec-bisect') do |dir|
      @download_dir = dir
      puts "Downloading artifact: #{artifact_name}"
      fetch_artifact(artifact_name, dir)
      read_xml_file(dir)
    end
  end

  def fetch_artifact(artifact_name, dir)
    _, stderr, status = Open3.capture3(
      'gh', 'run', 'download', @run_id,
      '--repo', REPO,
      '--name', artifact_name,
      '--dir', dir
    )
    return if status.success?

    puts "Error: Failed to download artifact '#{artifact_name}'"
    puts "  #{stderr.strip}" unless stderr.strip.empty?
    exit 1
  end

  def read_xml_file(dir)
    xml_file = File.join(dir, 'rspec.xml')
    unless File.exist?(xml_file)
      puts 'Error: rspec.xml not found in artifact'
      exit 1
    end
    File.read(xml_file)
  end

  def parse_xml(xml_content)
    doc = parse_xml_document(xml_content)
    seed = extract_seed(doc)
    spec_files, failures = extract_testcases(doc)
    if spec_files.empty?
      puts 'Error: No spec files found in rspec.xml'
      exit 1
    end
    [seed, spec_files, failures]
  end

  def parse_xml_document(xml_content)
    REXML::Document.new(xml_content)
  rescue REXML::ParseException => e
    puts "Error: Failed to parse rspec.xml - #{e.message.lines.first.strip}"
    exit 1
  end

  def extract_seed(doc)
    seed = nil
    doc.elements.each('testsuite/properties/property') do |prop|
      seed = prop.attributes['value'] if prop.attributes['name'] == 'seed'
    end
    if seed.nil? || seed.strip.empty?
      puts 'Error: Could not find valid seed in rspec.xml'
      exit 1
    end
    seed
  end

  def extract_testcases(doc)
    spec_files = Set.new
    failures = []
    doc.elements.each('testsuite/testcase') do |testcase|
      file = testcase.attributes['file']
      spec_files.add(file.sub(%r{^\./}, '')) if file
      extract_failure(testcase, file, failures)
    end
    [spec_files.to_a.sort, failures]
  end

  def extract_failure(testcase, file, failures)
    testcase.elements.each('failure') do |failure|
      failures << {
        name: testcase.attributes['name'],
        file: file&.sub(%r{^\./}, ''),
        message: failure.attributes['message']&.slice(0, 200)
      }
    end
  end

  def run_bisect(seed, spec_files, failed_files)
    needs_bundle_install = !bundle_ready?

    if @dry_run
      print_dry_run(seed, spec_files, needs_bundle_install)
      return
    end

    ensure_bundle_ready(needs_bundle_install)

    return unless @skip_verify || failed_files.empty? || verify_failure_reproduces(seed, failed_files)

    puts "\nRunning bisect command..."
    puts "Command: bundle exec rspec --seed #{seed} --bisect <#{spec_files.length} files>" if @verbose
    puts
    success = system('bundle', 'exec', 'rspec', '--seed', seed, '--bisect', *spec_files)
    exit 1 unless success
  end

  def verify_failure_reproduces(seed, failed_files)
    puts "\nVerifying failure reproduces (3 attempts with just the failing spec)..."
    failures = count_failures(seed, failed_files, 3)

    case failures
    when 0
      puts "\nTest passes in isolation - this is ideal for bisect."
      puts 'The failure is likely caused by test pollution from another spec.'
      true
    when 3
      prompt_continue_with_consistent_failure
    else
      prompt_continue_with_intermittent_failure(failures)
    end
  end

  def count_failures(seed, files, attempts)
    failures = 0
    attempts.times do |i|
      print "  Attempt #{i + 1}/#{attempts}: "
      success = system('bundle', 'exec', 'rspec', '--seed', seed, *files, %i[out err] => File::NULL)
      puts success ? 'passed' : 'FAILED'
      failures += 1 unless success
    end
    failures
  end

  def prompt_continue_with_intermittent_failure(failures)
    puts "\nWarning: Failure only reproduced #{failures}/3 times."
    puts 'The test may have timing issues or external dependencies.'
    puts 'Bisect may take longer due to inconsistent reproduction.'
    print 'Continue with bisect? [Y/n] '
    $stdin.gets&.strip&.downcase != 'n'
  end

  def prompt_continue_with_consistent_failure
    puts "\nWarning: Failure reproduced 3/3 times - this may not be flaky."
    puts 'If it fails consistently, bisect may run for a very long time.'
    puts 'Consider running the failing spec directly to debug.'
    print 'Continue with bisect anyway? [y/N] '
    $stdin.gets&.strip&.downcase == 'y'
  end

  def bundle_ready?
    _, status = Open3.capture2('bundle', 'check', err: '/dev/null')
    status.success?
  rescue Errno::ENOENT
    puts 'Error: Bundler not found. Install with: gem install bundler'
    exit 1
  end

  def print_dry_run(seed, spec_files, needs_bundle_install)
    puts "\n[DRY RUN] Would execute:"
    puts '  bundle install' if needs_bundle_install
    puts "  bundle exec rspec --seed #{seed} --bisect \\"
    spec_files.each_slice(3) { |files| puts "    #{files.join(' ')} \\" }
  end

  def ensure_bundle_ready(needs_install)
    return unless needs_install

    puts "\nBundle is not ready. Running 'bundle install'..."
    return if system('bundle', 'install')

    puts 'Error: bundle install failed. Run "bundle install" manually to see details.'
    exit 1
  end
end

HELP_TEXT = <<~HELP
  Usage: bin/flaky-spec-bisect [options] <github-actions-url-or-run-id>

  Downloads test artifacts from a failed GitHub Actions run and uses
  rspec --bisect to identify the minimal set of specs that reproduce
  the flaky failure.

  Arguments:
    <url-or-run-id>   GitHub Actions run URL or run ID
                      Examples:
                        https://github.com/department-of-veterans-affairs/vets-api/actions/runs/12345678
                        12345678

  Options:
    --group, -g NAME  Only process the specified test group (e.g., "Group 3")
    --dry-run, -n     Print the bisect command without executing
    --skip-verify     Skip the reproduction check before bisecting
    --verbose, -v     Show more detailed output
    --help, -h        Show this help message

  Prerequisites:
    - GitHub CLI (gh) must be installed and authenticated
    - Run from the vets-api root directory

  Examples:
    bin/flaky-spec-bisect https://github.com/department-of-veterans-affairs/vets-api/actions/runs/12345678
    bin/flaky-spec-bisect --group "Group 3" 12345678
    bin/flaky-spec-bisect --dry-run 12345678

  Documentation:
    https://depo-platform-documentation.scrollhelp.site/developer-docs/handling-flaky-unit-tests
HELP

# Parse arguments
options = {}
args = []

ARGV.each do |arg|
  case arg
  when '--help', '-h'
    puts HELP_TEXT
    exit 0
  when '--dry-run', '-n'
    options[:dry_run] = true
  when '--skip-verify'
    options[:skip_verify] = true
  when '--verbose', '-v'
    options[:verbose] = true
  when /^--group=(.+)$/, /^-g=(.+)$/
    options[:group] = Regexp.last_match(1)
  when '--group', '-g'
    options[:next_is_group] = true
  else
    if options[:next_is_group]
      options[:group] = arg
      options.delete(:next_is_group)
    else
      args << arg
    end
  end
end

if options[:next_is_group]
  puts 'Error: --group requires a value'
  exit 1
end

if args.empty?
  puts 'Error: Missing GitHub Actions URL or run ID'
  puts "Run 'bin/flaky-spec-bisect --help' for usage"
  exit 1
end

Signal.trap('INT') { exit 130 }

FlakySpecBisect.new(args.first, options).run
