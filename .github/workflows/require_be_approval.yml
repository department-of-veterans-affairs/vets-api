# Runs when PR reviews are submitted or PR is updated
name: Backend Approval
on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review, converted_to_draft]
    branches: [master]
  pull_request_review:
    types: [submitted, dismissed]
permissions:
  id-token: write
  contents: read
  pull-requests: write

concurrency:
  group: backend-approval-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  backend-approval-check:
    name: Succeed if backend approval is confirmed
    runs-on: ubuntu-latest
    permissions: write-all
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      - name: Get PR data
        id: pr_data
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          echo "pr_number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"

          # Fetch PR details
          PR_INFO=$(gh api /repos/${{ github.repository }}/pulls/${PR_NUMBER} --jq '{
            author: .user.login,
            draft: .draft,
            labels: [.labels[].name]
          }')

          PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.author')
          PR_DRAFT=$(echo "$PR_INFO" | jq -r '.draft')
          PR_LABELS=$(echo "$PR_INFO" | jq -c '.labels')

          echo "pr_author=${PR_AUTHOR}" >> "$GITHUB_OUTPUT"
          echo "pr_draft=${PR_DRAFT}" >> "$GITHUB_OUTPUT"
          echo "pr_labels=${PR_LABELS}" >> "$GITHUB_OUTPUT"

          echo "PR #${PR_NUMBER} - Author: ${PR_AUTHOR}, Draft: ${PR_DRAFT}"

      - name: Get changed files
        id: changed_files
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ steps.pr_data.outputs.pr_number }}"

          # Get all changed files in the PR
          CHANGED_FILES=$(gh api "/repos/${{ github.repository }}/pulls/${PR_NUMBER}/files" \
            --paginate --jq '.[].filename')

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Save to file for easier processing
          echo "$CHANGED_FILES" > /tmp/changed_files.txt

          FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
          echo "file_count=${FILE_COUNT}" >> "$GITHUB_OUTPUT"
      
      - name: Check file ownership
        id: file_ownership
        run: |
          set +e
          all_files_exempt=true
          CODEOWNERS_FILE=".github/CODEOWNERS"

          EXEMPT_TEAMS=(
            "octo-identity"
            "lighthouse-dash"
            "lighthouse-pivot"
            "lighthouse-banana-peels"
            "mobile-api-team"
            "fed-eng-admin"
          )

          echo "=== Analyzing file ownership ==="

          while IFS= read -r file || [ -n "$file" ]; do
            if [ -z "$file" ]; then continue; fi

            # Skip files under .github/ (like workflows or CODEOWNERS itself)
            if [[ "$file" == .github/* ]]; then
              echo "Skipping file under .github/: $file"
              continue
            fi

            echo "Checking: $file"

            # GitHub uses gitignore-style matching for CODEOWNERS
            # git check-ignore -v prints:
            # <source> <pattern> <file>
            check_output=$(git check-ignore -v "$file" 2>/dev/null)

            if [ -z "$check_output" ]; then
              echo "  ❌ No CODEOWNERS entry found (requires backend approval)"
              all_files_exempt=false
              continue
            fi

            pattern=$(echo "$check_output" | awk '{print $2}')
            echo "  Matched CODEOWNERS pattern: $pattern"

            # Extract the actual owners from the matching pattern
            owners=$(grep -E "^${pattern}[[:space:]]+" "$CODEOWNERS_FILE" | awk '{for (i=2;i<=NF;i++) print $i}')
            echo "  Owners: $owners"

            # If backend-review-group owns it → requires approval
            if echo "$owners" | grep -q "@department-of-veterans-affairs/backend-review-group"; then
              echo "  ❌ Owned by backend-review-group (requires approval)"
              all_files_exempt=false
              continue
            fi

            # Check whether the file is owned *only* by exempt teams
            file_is_exempt=false
            for team in "${EXEMPT_TEAMS[@]}"; do
              if echo "$owners" | grep -q "@department-of-veterans-affairs/${team}"; then
                echo "  ✓ Owned by exempt team: ${team}"
                file_is_exempt=true
                break
              fi
            done

            if [ "$file_is_exempt" = "false" ]; then
              echo "  ❌ Not owned by exempt team (requires backend approval)"
              all_files_exempt=false
            fi

          done < /tmp/changed_files.txt

          echo ""
          echo "=== Result ==="
          if [[ "$all_files_exempt" == "true" ]]; then
            echo "✓ All changed files are owned exclusively by exempt teams"
          else
            echo "✗ Some files require backend approval"
          fi

          echo "all_files_exempt=${all_files_exempt}" >> "$GITHUB_OUTPUT"

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          role-to-assume: ${{ vars.AWS_ASSUME_ROLE }}
          aws-region: "us-gov-west-1"
      - name: Get bot token
        uses: marvinpinto/action-inject-ssm-secrets@latest
        with:
          ssm_parameter: /devops/VA_VSP_BOT_GITHUB_TOKEN
          env_variable_name: VA_VSP_BOT_GITHUB_TOKEN
      - name: Check exemption and approval status
        id: check_status
        env:
          GITHUB_TOKEN: ${{ env.VA_VSP_BOT_GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr_data.outputs.pr_number }}
          PR_AUTHOR: ${{ steps.pr_data.outputs.pr_author }}
          PR_LABELS: ${{ steps.pr_data.outputs.pr_labels }}
          ALL_FILES_EXEMPT: ${{ steps.file_ownership.outputs.all_files_exempt }}
        run: |
          # Initialize status
          exempt=false
          exempt_reason=""
          backend_approved=false
          requires_approval=true

          # Define exempt teams
          EXEMPT_TEAMS=(
            octo-identity
            lighthouse-dash
            lighthouse-pivot
            lighthouse-banana-peels
            mobile-api-team
            fed-eng-admin
          )

          # Check: Are all files owned by exempt teams? (NEW)
          if [[ "${exempt}" == "false" && "${ALL_FILES_EXEMPT}" == "true" ]]; then
            echo "✓ All changed files owned exclusively by exempt teams (CODEOWNERS)"
            exempt=true
            exempt_reason="file ownership"
            requires_approval=false
          fi

          # Check: If not exempt, verify backend approval
          if [[ "${requires_approval}" == "true" ]]; then
            # Get backend-review-group members
            BACKEND_REVIEWERS=$(gh api \
              /orgs/department-of-veterans-affairs/teams/backend-review-group/members \
              --jq '.[].login' | tr '\n' '|' | sed 's/|$//')

            echo "Backend reviewers: ${BACKEND_REVIEWERS}"
            # Get current approvals (most recent per user)
            readarray -t APPROVALS < <(
              gh api /repos/${{ github.repository }}/pulls/${PR_NUMBER}/reviews --jq '
                [.[] | select(.state == "APPROVED")]
                | sort_by(.submitted_at)
                | reverse
                | unique_by(.user.login)
                | .[].user.login
              ' || true
            )

            # Check if any approver is from backend-review-group
            for approver in "${APPROVALS[@]}"; do
              if echo "$approver" | grep -iqE "^(${BACKEND_REVIEWERS})$"; then
                echo "✓ Backend approval confirmed by '${approver}'"
                backend_approved=true
                requires_approval=false
                break
              fi
            done
          fi

          # Output results
          echo "exempt=${exempt}" >> "$GITHUB_OUTPUT"
          echo "exempt_reason=${exempt_reason}" >> "$GITHUB_OUTPUT"
          echo "backend_approved=${backend_approved}" >> "$GITHUB_OUTPUT"
          echo "requires_approval=${requires_approval}" >> "$GITHUB_OUTPUT"

          # Summary
          echo "=== Summary ==="
          echo "Exempt: ${exempt}"
          if [[ "${exempt}" == "true" ]]; then
            echo "Exempt Reason: ${exempt_reason}"
          fi
          echo "Backend Approved: ${backend_approved}"
          echo "Requires Approval: ${requires_approval}"
      - name: Update labels
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr_data.outputs.pr_number }}
          EXEMPT: ${{ steps.check_status.outputs.exempt }}
          REQUIRES_APPROVAL: ${{ steps.check_status.outputs.requires_approval }}

        run: |
          # Add/remove exempt-be-review label
          if [[ "${EXEMPT}" == "true" ]]; then
            gh pr edit ${PR_NUMBER} --add-label "exempt-be-review" || true
            gh pr edit ${PR_NUMBER} --remove-label "require-backend-approval" || true
          fi

          # Add/remove require-backend-approval label
          if [[ "${REQUIRES_APPROVAL}" == "true" ]]; then
            gh pr edit ${PR_NUMBER} --add-label "require-backend-approval" || true
          else
            gh pr edit ${PR_NUMBER} --remove-label "require-backend-approval" || true
          fi

      - name: Check result
        if: steps.check_status.outputs.requires_approval == 'true'
        run: |
          echo "error  This PR requires approval from the backend-review-group before it can be merged."
          echo "error  If this PR should be exempt ensure:"
          echo "error    all changed files are owned exclusively by exempt teams in CODEOWNERS"
          exit 1

      - name: Approval confirmed
        if: steps.check_status.outputs.requires_approval == 'false'
        run: |
          if [[ "${{ steps.check_status.outputs.exempt }}" == "true" ]]; then
            echo "✓ PR is exempt from backend approval requirement"
            echo "  Reason: ${{ steps.check_status.outputs.exempt_reason }}"
          else
            echo "✓ Backend approval confirmed"
          fi
          exit 0
